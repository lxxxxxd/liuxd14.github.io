# 代码生成

源程序（src） --> 前端 --中间代码（IR）--> 代码优化器 ---中间代码（IR）--> 代码生成器 -->目标程序（bin） 

从数学上讲，为给定源程序生成一个最优的目标代码是不可判定的问题，在代码生成中碰到的很多子问题都具有难以处理的计算复杂性，比如寄存器分配。

在实践中，我们必须使用那些能够产生良好但不一定是最优的代码启发性技术。

代码生成器主要有三个任务：指令选择，寄存器分配和指派，指令排序。

## 代码生成器设计问题

依赖：（1）中间表示形式；（2）目标语言；（3）运行时刻系统；
标准：（1）生成正确的代码，保持源程序语义含义；（2）易于实现和维护；

常见的目标体系结构：RISC，CISC，基于堆栈的结构。

基于堆栈的机器，运算是通过把运算分量压入一个栈中，然后对栈顶的运算分量进行运算。为了提高性能，栈顶的元素通常保存在寄存器中。随着JVM的出现，又复活了。

编译 + 链接

（1）不链接：输出一个使用绝对地址的机器语言程序的优点是程序可以房子内存中某个固定的位置上，并立即执行。程序可以很快的编译和执行。缺点，体积大，占用内存。

（2）链接：输出可重定位的机器语言程序，即目标模块，可以使各个子程序分别编译。一组可以重定位的目标模块可以被一个链接加载器链接到一起并加载运行。如果我们要生成可重定位的目标模块，
我们必须为链接和加载付出代价。（时间换空间）这样可以得到很大的灵活性。我们可以把子程序分开编译，并能够从一个目标模块中调用其他已经编译好的程序。如果目标机器没有自动处理重定位，
编译器就必须向加载器提供明确的重定位信息，以便把分开编译的程序连接起来。

（3）输出一个汇编程序使代码生成过程变得稍微容易一些。我们可以生成符号指令，并使用**汇编器的宏机制来帮助生成代码**。这么做的代价是代码生成之后还需要增加一个汇编步骤。

